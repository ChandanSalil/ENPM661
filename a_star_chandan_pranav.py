# -*- coding: utf-8 -*-
"""a_star_chandan_pranav.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jSx1uYNAEjmCBb2c9Du3y8Kh3Z2293vY
"""

import numpy as np
from math import dist
import matplotlib.pyplot as plt
import time
import heapq


#Defning a class

#Storing nodes as objects

class Node:

    def __init__(self, x, y, robot_angle, cost, par_key, cost_to_go=0):
        self.x = x
        self.y = y
        self.robot_angle = robot_angle
        self.cost = cost
        self.par_key = par_key
        self.cost_to_go = cost_to_go

    def __lt__(self, other):
        a = self.cost + self.cost_to_go < other.cost + other.cost_to_go
        return a


#Now we define the action sets used in the programs and calculate the costs 

#turn left 60 degrees

def turn_left_60(x, y, robot_angle, robot_step, cost):
    robot_angle = robot_angle + 60
    x = x + (robot_step * np.cos(np.radians(robot_angle)))
    y = y + (robot_step * np.sin(np.radians(robot_angle)))

    x = round(x)
    y = round(y)
    cost += 1 
    return x, y, robot_angle, cost


def turn_left_30(x, y, robot_angle, robot_step, cost):
    robot_angle += 30
    k1 = robot_step * np.cos(np.radians(robot_angle))
    x += k1
    l1 = robot_step * np.sin(np.radians(robot_angle))
    y +=  l1

    x = round(x)
    y = round(y)
    cost += 1 
    return x, y, robot_angle, cost


def move_ahead(x, y, robot_angle, robot_step, cost):
    robot_angle +=  0
    k2 = robot_step * np.cos(np.radians(robot_angle))
    x += k2 
    l2 = robot_step * np.sin(np.radians(robot_angle)) 
    y += l2

    x = round(x)
    y = round(y)
    cost += 1
    return x, y, robot_angle, cost

def turn_right_30(x, y, robot_angle, robot_step, cost):
    robot_angle  -=  30
    k3 = robot_step * np.cos(np.radians(robot_angle))
    x += k3
    l3 = robot_step * np.sin(np.radians(robot_angle)) 
    y += l3 

    x = round(x)
    y = round(y)
    cost += 1
    return x, y, robot_angle, cost


def turn_right_60(x, y, robot_angle, robot_step, cost):
    robot_angle -=  60
    k4 = robot_step * np.cos(np.radians(robot_angle))
    x += k4
    l4 = robot_step * np.sin(np.radians(robot_angle))
    y += l4 

    x = round(x)
    y = round(y)
    
    cost += 1
    
    return x, y, robot_angle, cost


#A function defined to perform actions
def robot_act_set(robot_movement, x, y, robot_angle, robot_step, cost):
    
    if robot_movement == 0:
    
        return turn_left_60(x, y, robot_angle, robot_step, cost)
    
    elif robot_movement == 1:
    
        return turn_left_30(x, y, robot_angle, robot_step, cost)
    
    elif robot_movement == 2:
    
        return move_ahead(x, y, robot_angle, robot_step, cost)
    
    elif robot_movement == 3:
    
        return turn_right_30(x, y, robot_angle, robot_step, cost)
    
    elif robot_movement == 4:
    
        return turn_right_60(x, y, robot_angle, robot_step, cost)
    
    else:
        return None



def map(map_width, map_height, rbt_clr, rbt_rad):
    
    
    map = np.full((map_height, map_width), 0)

    for y in range(0, map_height):
        for x in range(0, map_width):

           
            #Generating first rectangle
            
            rect_1_1 = (x + (rbt_clr + rbt_rad)) - 100
            
            rect_1_2 = (y - (rbt_clr + rbt_rad)) - 100
            
            rect_1_3 = (x - (rbt_clr + rbt_rad)) - 150

            #Generating second rectangle
            
            rect_2_1 = (x + (rbt_clr + rbt_rad)) - 100
            
            rect_2_3 = (x - (rbt_clr + rbt_rad)) - 150
            
            rect_2_4 = (y + (rbt_clr + rbt_rad)) - 150

            #Generating Hexagon
            
            hex_6 = (y + (rbt_clr + rbt_rad)) + 0.58 * (
                        x + (rbt_clr + rbt_rad)) - 223.18
            
            hex_5 = (y + (rbt_clr + rbt_rad)) - 0.58 * (
                        x - (rbt_clr + rbt_rad)) + 123.21
            
            hex_4 = (x - (rbt_clr + rbt_rad)) - 364.95
            
            hex_3 = (y - (rbt_clr + rbt_rad)) + 0.58 * (
                        x - (rbt_clr + rbt_rad)) - 373.21
            
            hex_2 = (y - (rbt_clr + rbt_rad)) - 0.58 * (
                        x + (rbt_clr + rbt_rad)) - 26.82
            
            hex_1 = (x + (rbt_clr + rbt_rad)) - 235.040

            #Generating Triangle
            
            triangle_1 = (x + (rbt_clr + rbt_rad)) - 460
            
            triangle_2 = (y - (rbt_clr + rbt_rad)) + 2 * (x - (rbt_clr + rbt_rad)) - 1145
            
            triangle_3 = (y + (rbt_clr + rbt_rad)) - 2 * (x - (rbt_clr + rbt_rad)) + 895

          
            
            if ((
                    hex_6 > 0 and hex_5 > 0 and hex_4 < 0 and hex_3 < 0 and hex_2 < 0 and hex_1 > 0) or (
                    rect_1_1 > 0 and rect_1_2 < 0 and rect_1_3 < 0) or (
                    rect_2_1 > 0 and rect_2_3 < 0 and rect_2_4 > 0) or (
                    triangle_1 > 0 and triangle_2 < 0 and triangle_3 > 0)):
                
                map[y, x] = 1

           

            #First Rectangle 
            
            r_1_1 = (x) - 100
            
            r_1_2 = (y) - 100
            
            r_1_3 = (x) - 150
            

            #Lower Rectangular 
            r_2_1 = (x) - 100
            
            r_2_3 = (x) - 150
            
            r_2_4 = (y) - 150

            #Hexagon
            h_6 = (y) + 0.58 * (x) - 223.18
            
            h_5 = (y) - 0.58 * (x) + 123.21
            
            h_4 = (x) - 364.95
            
            h_3 = (y) + 0.58 * (x) - 373.21
            
            h_2 = (y) - 0.58 * (x) - 26.82
            
            h_1 = (x) - 235.04

            #Triangle
            t_1 = (x) - 460
            t_2 = (y) + 2 * (x) - 1145
            t_3 = (y) - 2 * (x) + 895

            #Set the line constraint along with buffer
            if ((h_6 > 0 and h_5 > 0 and h_4 < 0 and h_3 < 0 and h_2 < 0 and h_1 > 0) or (
                    r_1_1 > 0 and r_1_2 < 0 and r_1_3 < 0) or (r_2_1 > 0 and r_2_3 < 0 and r_2_4 > 0) or (
                    t_1 > 0 and t_2 < 0 and t_3 > 0)):
                map[y, x] = 2

    return map


# Now we check validity of the movement

def check_movement(x_cord_check, y_cord_check, map):
    
    check_movement = map.shape

    if (x_cord_check > check_movement[1] or x_cord_check < 0 or y_cord_check > check_movement[0] or y_cord_check < 0):
        
        return False

    else:
        try:
            
            if (map[y_cord_check][x_cord_check] == 1 or map[y_cord_check][x_cord_check] == 2):
                
                return False
        
        except:
            pass
    return True


#Define a function is we reached goal or not 

def check_end(loc_curr, goal):
    
    distance = dist((loc_curr.x, loc_curr.y), (goal.x, goal.y))
    
   # define the threshold for goal 
   
    threshold = 1.5
    
   # successful case
    
    if distance < threshold:
        
        return True
    else:
        return False


#Define a function to create unique key for each node

def node_key(node):
    
    node_key = 222 * node.x + 111 * node.y
    
    return node_key


#Implement the A* algorithm 

def funtc_astar(start, goal, map, robot_step):
    
    if check_end(start, goal):
        return None
    
    goal_node = goal
    
    start_node = start

    # all movements possible
    
    robot_moves = [0, 1, 2, 3, 4] 
    
    list_open = {}  #Open list
    
    list_closed = {}  #Closed list
    
    priority_queue = []  
    
    nodes_each = []  

    start_key = node_key(start_node)  
    
    list_open[(start_key)] = start_node 

    heapq.heappush(priority_queue, [start_node.cost, start_node])  

    while (len(priority_queue) != 0): 
        
        #Getting least cost from queue
        curr_node = (heapq.heappop(priority_queue))[1] 
        
        nodes_each.append([curr_node.x, curr_node.y, curr_node.robot_angle]) 
        
        curr_key = node_key(curr_node) 
        
        if check_end(curr_node, goal_node): 
            
            goal_node.par_key = curr_node.par_key
            #Success
            goal_node.cost = curr_node.cost
            
            print("Goal Node found")
            
            return nodes_each, 1

        if curr_key in list_closed: 
            continue
        else:  
            list_closed[curr_key] = curr_node
        
        #Removing the current node from the open list
        
        del list_open[curr_key] 
        
        
        for robot_movement in robot_moves: 
            x, y, robot_angle, cost = robot_act_set(robot_movement, curr_node.x, curr_node.y, curr_node.robot_angle, robot_step,
                                           curr_node.cost)

            cost_to_go = dist((x, y), (goal.x, goal.y))  

            new_node = Node(x, y, robot_angle, cost, curr_node, cost_to_go)

            key_new_node = node_key(new_node)

            if not check_movement(new_node.x, new_node.y, map): 
                continue
            elif key_new_node in list_closed: 
                
                continue

            if key_new_node in list_open: 
                
                if new_node.cost < list_open[key_new_node].cost:
                
                    list_open[key_new_node].cost = new_node.cost
                
                    list_open[key_new_node].par_key = new_node.par_key
            else: 
                
                list_open[key_new_node] = new_node

            heapq.heappush(priority_queue, [(new_node.cost + new_node.cost_to_go), new_node])

    return nodes_each, 0


#Let us mark the shortest path

def marker_route(goal):
    
    route_x = []
    
    route_y = []
    
    route_x.append(goal.x)
    
    route_y.append(goal.y)

    parent = goal.par_key
    while parent != -1:
        route_x.append(parent.x)
        route_y.append(parent.y)
        parent = parent.par_key

    route_x.reverse()
    route_y.reverse()

    x = np.asarray(route_x)
    y = np.asanyarray(route_y)

    return x, y


#Plotting the map and route 
def plot(start_node, goal_node, route_x, route_y, nodes_each, map):
    plt.figure()
    
    #Plotting the start node and the goal node
    
    plt.plot(start_node.x, start_node.y, "Dw")
    
    plt.plot(goal_node.x, goal_node.y, "Dr")

    #Plotting the workspace
    
    plt.imshow(map, "YlOrBr")
    
    ax = plt.gca()
    
    ax.invert_yaxis()  

    #Plot all  nodes
    
    for i in range(len(nodes_each)):
        plt.plot(nodes_each[i][0], nodes_each[i][1], "2g-")

    #plotting the most optimal path or the shortest path found
    
    plt.plot(route_x, route_y, ':y')
    plt.show()
    plt.pause(3)
    #closing all 
    plt.close('all')


#Writing the Main function
if __name__ == '__main__':
    
    rbt_clr = int(input("Enter the robot clearance: "))
    
    rbt_rad = int(input("Enter the robot radius: "))
    
    robot_robot_step = int(input("Enter the robot stepsize: "))

    map_width = 600 
    
    map_height = 250 
    map = map(map_width, map_height, rbt_clr, rbt_rad) 
    cost_to_go = 0 

    
    start_x = int(input("Enter the X Co-ordinate of the starting point: "))
    
    start_y = int(input("Enter the Y Co-ordinate of the starting point: "))
    
    start_robot_angle = int(input("Enter the Start Orientation of the Robot: "))
    
    

    #Rounding off the start angle to the nearest multiple of 30
    
    number = int(start_robot_angle)
    
    remainder = number % 30
    if remainder < 15:
        start_robot_angle = number - remainder
    else:
        start_robot_angle = number + (30 - remainder)

    #Checking the validity of the given starting point in the workspace
    if not check_movement(start_x, start_y, map):
        print("Start node is either out of bounds or in the obstacle")
        exit(-1)

    #Enter the x cord of goal
    goal_x = int(input("Enter the X Co-ordinate of the goal node: "))
    #Enter the y cord of goal
    goal_y = int(input("Enter the Y Co-ordinate of the goal node: "))
    #Enter the angle of goal
    goal_robot_angle = int(input("Enter the Goal Orientation of the Robot: "))
    
    #Rounding off the goal  multiple of 30
    
    number = int(goal_robot_angle)
    
    remainder = number % 30
    
    if remainder < 15:
    
        goal_robot_angle = number - remainder
    
    else:
    
        goal_robot_angle = number + (30 - remainder)

    #check goal node 
    if not check_movement(goal_x, goal_y, map):
        print("Goal node is either out of bounds or in the obstacle")
        exit(-1)
    #start timer
    timer_start = time.time() 

    #initialize start and goal node
    
    start_node = Node(start_x, start_y, start_robot_angle, 0.0, -1, cost_to_go)
    
    goal_node = Node(goal_x, goal_y, goal_robot_angle, 0.0, -1, cost_to_go)
    
    nodes_each, flag = funtc_astar(start_node, goal_node, map, robot_robot_step)

    #marking the optimal path 
    
    if (flag) == 1:
        route_x, route_y = marker_route(goal_node)
        cost = goal_node.cost 
        #total cost
        print("the total cost:", cost)
        plot(start_node, goal_node, route_x, route_y, nodes_each, map)
        #stop the timer
        timer_stop = time.time()
        #total time 
        total_time = timer_stop - timer_start
        #print total time
        print("Total Time taken:  ", total_time)

    else:
        print("Path couldn't be found")